[ { state: Symbol(block) } ]
TOP: 1 { state: Symbol(block) }
INPUT: Symbol(functionKeyword)
NEW STATE: Symbol(functionDeclaration.afterKeyword) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  }
]
TOP: 2 {
  state: Symbol(functionDeclaration.afterKeyword),
  node: { type: Symbol(functionKeyword) }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(functionDeclaration.afterFunctionName) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  }
]
TOP: 3 {
  state: Symbol(functionDeclaration.afterFunctionName),
  node: { type: Symbol(identifier), value: 'test' }
}
INPUT: Symbol(leftParenthesis)
NEW STATE: Symbol(functionDeclaration.beforeFirstArgument) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeFirstArgument),
    node: { type: Symbol(leftParenthesis) }
  }
]
TOP: 4 {
  state: Symbol(functionDeclaration.beforeFirstArgument),
  node: { type: Symbol(leftParenthesis) }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(functionDeclaration.afterArgument) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeFirstArgument),
    node: { type: Symbol(leftParenthesis) }
  },
  {
    state: Symbol(functionDeclaration.afterArgument),
    node: { type: Symbol(identifier), value: 'a' }
  }
]
TOP: 5 {
  state: Symbol(functionDeclaration.afterArgument),
  node: { type: Symbol(identifier), value: 'a' }
}
INPUT: Symbol(comma)
NEW STATE: Symbol(functionDeclaration.beforeArgument) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeFirstArgument),
    node: { type: Symbol(leftParenthesis) }
  },
  {
    state: Symbol(functionDeclaration.afterArgument),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(functionDeclaration.beforeArgument),
    node: { type: Symbol(comma) }
  }
]
TOP: 6 {
  state: Symbol(functionDeclaration.beforeArgument),
  node: { type: Symbol(comma) }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(functionDeclaration.afterArgument) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeFirstArgument),
    node: { type: Symbol(leftParenthesis) }
  },
  {
    state: Symbol(functionDeclaration.afterArgument),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(functionDeclaration.beforeArgument),
    node: { type: Symbol(comma) }
  },
  {
    state: Symbol(functionDeclaration.afterArgument),
    node: { type: Symbol(identifier), value: 'b' }
  }
]
TOP: 7 {
  state: Symbol(functionDeclaration.afterArgument),
  node: { type: Symbol(identifier), value: 'b' }
}
INPUT: Symbol(rightParenthesis)
NEW STATE: Symbol(reduce.functionArguments) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeFirstArgument),
    node: { type: Symbol(leftParenthesis) }
  },
  {
    state: Symbol(functionDeclaration.afterArgument),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(functionDeclaration.beforeArgument),
    node: { type: Symbol(comma) }
  },
  {
    state: Symbol(functionDeclaration.afterArgument),
    node: { type: Symbol(identifier), value: 'b' }
  },
  {
    state: Symbol(reduce.functionArguments),
    node: { type: Symbol(rightParenthesis) }
  }
]
TOP: 8 {
  state: Symbol(reduce.functionArguments),
  node: { type: Symbol(rightParenthesis) }
}
reduceFunctionArguments
[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  }
]
TOP: 4 {
  state: Symbol(functionDeclaration.beforeBody),
  node: [
    { type: Symbol(identifier), value: 'a' },
    { type: Symbol(identifier), value: 'b' }
  ]
}
INPUT: Symbol(leftCurlyBracket)
NEW STATE: Symbol(block) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } }
]
TOP: 5 { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } }
INPUT: Symbol(variableKeyword)
NEW STATE: Symbol(assignment.afterDeclarationKeyword) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  }
]
TOP: 6 {
  state: Symbol(assignment.afterDeclarationKeyword),
  node: { type: Symbol(variableKeyword), value: 'let' }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(assignment.afterVariableName) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'c' }
  }
]
TOP: 7 {
  state: Symbol(assignment.afterVariableName),
  node: { type: Symbol(identifier), value: 'c' }
}
INPUT: Symbol(assignmentOperator)
NEW STATE: Symbol(assignment.afterAssignmentOperator) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'c' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  }
]
TOP: 8 {
  state: Symbol(assignment.afterAssignmentOperator),
  node: { type: Symbol(assignmentOperator) }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(expression.afterAdditiveOperand) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'c' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'a' }
  }
]
TOP: 9 {
  state: Symbol(expression.afterAdditiveOperand),
  node: { type: Symbol(identifier), value: 'a' }
}
INPUT: Symbol(multiplicativeOperator)
NEW STATE: Symbol(expression.afterMultiplicativeOperator) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'c' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(expression.afterMultiplicativeOperator),
    node: { type: Symbol(multiplicativeOperator), value: '*' }
  }
]
TOP: 10 {
  state: Symbol(expression.afterMultiplicativeOperator),
  node: { type: Symbol(multiplicativeOperator), value: '*' }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(expression.afterMultiplicativeOperand) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'c' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(expression.afterMultiplicativeOperator),
    node: { type: Symbol(multiplicativeOperator), value: '*' }
  },
  {
    state: Symbol(expression.afterMultiplicativeOperand),
    node: { type: Symbol(identifier), value: 'a' }
  }
]
TOP: 11 {
  state: Symbol(expression.afterMultiplicativeOperand),
  node: { type: Symbol(identifier), value: 'a' }
}
INPUT: Symbol(semicolon)
NEW STATE: Symbol(reduce.completeExpression) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'c' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(expression.afterMultiplicativeOperator),
    node: { type: Symbol(multiplicativeOperator), value: '*' }
  },
  {
    state: Symbol(expression.afterMultiplicativeOperand),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(reduce.completeExpression),
    node: { type: Symbol(semicolon) }
  }
]
TOP: 12 {
  state: Symbol(reduce.completeExpression),
  node: { type: Symbol(semicolon) }
}
reduceMultiplicativeTerm
reduceAdditiveTerm
reduceCompleteExpression
[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'c' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(reduce.assignment),
    node: {
      type: Symbol(completeExpression),
      operator: [Object],
      leftOperand: [Object],
      rightOperand: [Object]
    }
  }
]
TOP: 9 {
  state: Symbol(reduce.assignment),
  node: {
    type: Symbol(completeExpression),
    operator: { type: Symbol(multiplicativeOperator), value: '*' },
    leftOperand: { type: Symbol(identifier), value: 'a' },
    rightOperand: { type: Symbol(identifier), value: 'a' }
  }
}
reduceAssignment
[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  }
]
TOP: 6 {
  state: Symbol(block),
  node: {
    type: Symbol(assignmentStatement),
    name: 'c',
    value: {
      type: Symbol(completeExpression),
      operator: [Object],
      leftOperand: [Object],
      rightOperand: [Object]
    },
    declarationType: 'let'
  }
}
INPUT: Symbol(variableKeyword)
NEW STATE: Symbol(assignment.afterDeclarationKeyword) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  }
]
TOP: 7 {
  state: Symbol(assignment.afterDeclarationKeyword),
  node: { type: Symbol(variableKeyword), value: 'let' }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(assignment.afterVariableName) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'd' }
  }
]
TOP: 8 {
  state: Symbol(assignment.afterVariableName),
  node: { type: Symbol(identifier), value: 'd' }
}
INPUT: Symbol(assignmentOperator)
NEW STATE: Symbol(assignment.afterAssignmentOperator) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'd' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  }
]
TOP: 9 {
  state: Symbol(assignment.afterAssignmentOperator),
  node: { type: Symbol(assignmentOperator) }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(expression.afterAdditiveOperand) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'd' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'b' }
  }
]
TOP: 10 {
  state: Symbol(expression.afterAdditiveOperand),
  node: { type: Symbol(identifier), value: 'b' }
}
INPUT: Symbol(multiplicativeOperator)
NEW STATE: Symbol(expression.afterMultiplicativeOperator) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'd' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'b' }
  },
  {
    state: Symbol(expression.afterMultiplicativeOperator),
    node: { type: Symbol(multiplicativeOperator), value: '*' }
  }
]
TOP: 11 {
  state: Symbol(expression.afterMultiplicativeOperator),
  node: { type: Symbol(multiplicativeOperator), value: '*' }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(expression.afterMultiplicativeOperand) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'd' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'b' }
  },
  {
    state: Symbol(expression.afterMultiplicativeOperator),
    node: { type: Symbol(multiplicativeOperator), value: '*' }
  },
  {
    state: Symbol(expression.afterMultiplicativeOperand),
    node: { type: Symbol(identifier), value: 'b' }
  }
]
TOP: 12 {
  state: Symbol(expression.afterMultiplicativeOperand),
  node: { type: Symbol(identifier), value: 'b' }
}
INPUT: Symbol(semicolon)
NEW STATE: Symbol(reduce.completeExpression) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'd' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'b' }
  },
  {
    state: Symbol(expression.afterMultiplicativeOperator),
    node: { type: Symbol(multiplicativeOperator), value: '*' }
  },
  {
    state: Symbol(expression.afterMultiplicativeOperand),
    node: { type: Symbol(identifier), value: 'b' }
  },
  {
    state: Symbol(reduce.completeExpression),
    node: { type: Symbol(semicolon) }
  }
]
TOP: 13 {
  state: Symbol(reduce.completeExpression),
  node: { type: Symbol(semicolon) }
}
reduceMultiplicativeTerm
reduceAdditiveTerm
reduceCompleteExpression
[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'let' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'd' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(reduce.assignment),
    node: {
      type: Symbol(completeExpression),
      operator: [Object],
      leftOperand: [Object],
      rightOperand: [Object]
    }
  }
]
TOP: 10 {
  state: Symbol(reduce.assignment),
  node: {
    type: Symbol(completeExpression),
    operator: { type: Symbol(multiplicativeOperator), value: '*' },
    leftOperand: { type: Symbol(identifier), value: 'b' },
    rightOperand: { type: Symbol(identifier), value: 'b' }
  }
}
reduceAssignment
[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'd',
      value: [Object],
      declarationType: 'let'
    }
  }
]
TOP: 7 {
  state: Symbol(block),
  node: {
    type: Symbol(assignmentStatement),
    name: 'd',
    value: {
      type: Symbol(completeExpression),
      operator: [Object],
      leftOperand: [Object],
      rightOperand: [Object]
    },
    declarationType: 'let'
  }
}
INPUT: Symbol(returnKeyword)
NEW STATE: Symbol(returnStatement.afterKeyword) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'd',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(returnStatement.afterKeyword),
    node: { type: Symbol(returnKeyword) }
  }
]
TOP: 8 {
  state: Symbol(returnStatement.afterKeyword),
  node: { type: Symbol(returnKeyword) }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(expression.afterAdditiveOperand) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'd',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(returnStatement.afterKeyword),
    node: { type: Symbol(returnKeyword) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'c' }
  }
]
TOP: 9 {
  state: Symbol(expression.afterAdditiveOperand),
  node: { type: Symbol(identifier), value: 'c' }
}
INPUT: Symbol(additiveOperator)
NEW STATE: Symbol(expression.afterAdditiveOperator) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'd',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(returnStatement.afterKeyword),
    node: { type: Symbol(returnKeyword) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'c' }
  },
  {
    state: Symbol(expression.afterAdditiveOperator),
    node: { type: Symbol(additiveOperator), value: '+' }
  }
]
TOP: 10 {
  state: Symbol(expression.afterAdditiveOperator),
  node: { type: Symbol(additiveOperator), value: '+' }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(expression.afterAdditiveOperand) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'd',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(returnStatement.afterKeyword),
    node: { type: Symbol(returnKeyword) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'c' }
  },
  {
    state: Symbol(expression.afterAdditiveOperator),
    node: { type: Symbol(additiveOperator), value: '+' }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'd' }
  }
]
TOP: 11 {
  state: Symbol(expression.afterAdditiveOperand),
  node: { type: Symbol(identifier), value: 'd' }
}
INPUT: Symbol(semicolon)
NEW STATE: Symbol(reduce.completeExpression) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'd',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(returnStatement.afterKeyword),
    node: { type: Symbol(returnKeyword) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'c' }
  },
  {
    state: Symbol(expression.afterAdditiveOperator),
    node: { type: Symbol(additiveOperator), value: '+' }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'd' }
  },
  {
    state: Symbol(reduce.completeExpression),
    node: { type: Symbol(semicolon) }
  }
]
TOP: 12 {
  state: Symbol(reduce.completeExpression),
  node: { type: Symbol(semicolon) }
}
reduceMultiplicativeTerm
reduceAdditiveTerm
reduceCompleteExpression
[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'd',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(returnStatement.afterKeyword),
    node: { type: Symbol(returnKeyword) }
  },
  {
    state: Symbol(reduce.returnStatement),
    node: {
      type: Symbol(completeExpression),
      operator: [Object],
      leftOperand: [Object],
      rightOperand: [Object]
    }
  }
]
TOP: 9 {
  state: Symbol(reduce.returnStatement),
  node: {
    type: Symbol(completeExpression),
    operator: { type: Symbol(additiveOperator), value: '+' },
    leftOperand: { type: Symbol(identifier), value: 'c' },
    rightOperand: { type: Symbol(identifier), value: 'd' }
  }
}
reduceReturnStatement
[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'd',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: { type: Symbol(returnStatement), value: [Object] }
  }
]
TOP: 8 {
  state: Symbol(block),
  node: {
    type: Symbol(returnStatement),
    value: {
      type: Symbol(completeExpression),
      operator: [Object],
      leftOperand: [Object],
      rightOperand: [Object]
    }
  }
}
INPUT: Symbol(rightCurlyBracket)
NEW STATE: Symbol(reduce.block) 

[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  { state: Symbol(block), node: { type: Symbol(leftCurlyBracket) } },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'c',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'd',
      value: [Object],
      declarationType: 'let'
    }
  },
  {
    state: Symbol(block),
    node: { type: Symbol(returnStatement), value: [Object] }
  },
  {
    state: Symbol(reduce.block),
    node: { type: Symbol(rightCurlyBracket) }
  }
]
TOP: 9 {
  state: Symbol(reduce.block),
  node: { type: Symbol(rightCurlyBracket) }
}
[
  { state: Symbol(block) },
  {
    state: Symbol(functionDeclaration.afterKeyword),
    node: { type: Symbol(functionKeyword) }
  },
  {
    state: Symbol(functionDeclaration.afterFunctionName),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionDeclaration.beforeBody),
    node: [ [Object], [Object] ]
  },
  {
    state: Symbol(reduce.functionDeclaration),
    node: { type: Symbol(block), statements: [Array] }
  }
]
TOP: 5 {
  state: Symbol(reduce.functionDeclaration),
  node: { type: Symbol(block), statements: [ [Object] ] }
}
reduceFunctionDeclaration
[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  }
]
TOP: 2 {
  state: Symbol(block),
  node: {
    type: Symbol(functionDeclaration),
    name: 'test',
    parameters: [ [Object], [Object] ],
    body: { type: Symbol(block), statements: [Array] }
  }
}
INPUT: Symbol(variableKeyword)
NEW STATE: Symbol(assignment.afterDeclarationKeyword) 

[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  }
]
TOP: 3 {
  state: Symbol(assignment.afterDeclarationKeyword),
  node: { type: Symbol(variableKeyword), value: 'var' }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(assignment.afterVariableName) 

[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  }
]
TOP: 4 {
  state: Symbol(assignment.afterVariableName),
  node: { type: Symbol(identifier), value: 'a' }
}
INPUT: Symbol(assignmentOperator)
NEW STATE: Symbol(assignment.afterAssignmentOperator) 

[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  }
]
TOP: 5 {
  state: Symbol(assignment.afterAssignmentOperator),
  node: { type: Symbol(assignmentOperator) }
}
INPUT: Symbol(identifier)
NEW STATE: Symbol(expression.afterAdditiveOperand) 

[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'test' }
  }
]
TOP: 6 {
  state: Symbol(expression.afterAdditiveOperand),
  node: { type: Symbol(identifier), value: 'test' }
}
INPUT: Symbol(leftParenthesis)
NEW STATE: Symbol(functionApplication.beforeFirstArgument) 

[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionApplication.beforeFirstArgument),
    node: { type: Symbol(leftParenthesis) }
  }
]
TOP: 7 {
  state: Symbol(functionApplication.beforeFirstArgument),
  node: { type: Symbol(leftParenthesis) }
}
INPUT: Symbol(number)
NEW STATE: Symbol(functionApplication.afterArgument) 

[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionApplication.beforeFirstArgument),
    node: { type: Symbol(leftParenthesis) }
  },
  {
    state: Symbol(functionApplication.afterArgument),
    node: { type: Symbol(number), vlaue: '1' }
  }
]
TOP: 8 {
  state: Symbol(functionApplication.afterArgument),
  node: { type: Symbol(number), vlaue: '1' }
}
INPUT: Symbol(comma)
NEW STATE: Symbol(functionApplication.beforeArgument) 

[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionApplication.beforeFirstArgument),
    node: { type: Symbol(leftParenthesis) }
  },
  {
    state: Symbol(functionApplication.afterArgument),
    node: { type: Symbol(number), vlaue: '1' }
  },
  {
    state: Symbol(functionApplication.beforeArgument),
    node: { type: Symbol(comma) }
  }
]
TOP: 9 {
  state: Symbol(functionApplication.beforeArgument),
  node: { type: Symbol(comma) }
}
INPUT: Symbol(number)
NEW STATE: Symbol(functionApplication.afterArgument) 

[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionApplication.beforeFirstArgument),
    node: { type: Symbol(leftParenthesis) }
  },
  {
    state: Symbol(functionApplication.afterArgument),
    node: { type: Symbol(number), vlaue: '1' }
  },
  {
    state: Symbol(functionApplication.beforeArgument),
    node: { type: Symbol(comma) }
  },
  {
    state: Symbol(functionApplication.afterArgument),
    node: { type: Symbol(number), vlaue: '2' }
  }
]
TOP: 10 {
  state: Symbol(functionApplication.afterArgument),
  node: { type: Symbol(number), vlaue: '2' }
}
INPUT: Symbol(rightParenthesis)
NEW STATE: Symbol(reduce.functionApplication) 

[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: { type: Symbol(identifier), value: 'test' }
  },
  {
    state: Symbol(functionApplication.beforeFirstArgument),
    node: { type: Symbol(leftParenthesis) }
  },
  {
    state: Symbol(functionApplication.afterArgument),
    node: { type: Symbol(number), vlaue: '1' }
  },
  {
    state: Symbol(functionApplication.beforeArgument),
    node: { type: Symbol(comma) }
  },
  {
    state: Symbol(functionApplication.afterArgument),
    node: { type: Symbol(number), vlaue: '2' }
  },
  {
    state: Symbol(reduce.functionApplication),
    node: { type: Symbol(rightParenthesis) }
  }
]
TOP: 11 {
  state: Symbol(reduce.functionApplication),
  node: { type: Symbol(rightParenthesis) }
}
reduceFunctionApplication
[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: {
      type: Symbol(subexpression),
      functionName: 'test',
      arguments: [Array]
    }
  }
]
TOP: 6 {
  state: Symbol(expression.afterAdditiveOperand),
  node: {
    type: Symbol(subexpression),
    functionName: 'test',
    arguments: [ [Object], [Object] ]
  }
}
INPUT: Symbol(semicolon)
NEW STATE: Symbol(reduce.completeExpression) 

[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(expression.afterAdditiveOperand),
    node: {
      type: Symbol(subexpression),
      functionName: 'test',
      arguments: [Array]
    }
  },
  {
    state: Symbol(reduce.completeExpression),
    node: { type: Symbol(semicolon) }
  }
]
TOP: 7 {
  state: Symbol(reduce.completeExpression),
  node: { type: Symbol(semicolon) }
}
reduceMultiplicativeTerm
reduceAdditiveTerm
reduceCompleteExpression
[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(assignment.afterDeclarationKeyword),
    node: { type: Symbol(variableKeyword), value: 'var' }
  },
  {
    state: Symbol(assignment.afterVariableName),
    node: { type: Symbol(identifier), value: 'a' }
  },
  {
    state: Symbol(assignment.afterAssignmentOperator),
    node: { type: Symbol(assignmentOperator) }
  },
  {
    state: Symbol(reduce.assignment),
    node: {
      type: Symbol(completeExpression),
      functionName: 'test',
      arguments: [Array]
    }
  }
]
TOP: 6 {
  state: Symbol(reduce.assignment),
  node: {
    type: Symbol(completeExpression),
    functionName: 'test',
    arguments: [ [Object], [Object] ]
  }
}
reduceAssignment
[
  { state: Symbol(block) },
  {
    state: Symbol(block),
    node: {
      type: Symbol(functionDeclaration),
      name: 'test',
      parameters: [Array],
      body: [Object]
    }
  },
  {
    state: Symbol(block),
    node: {
      type: Symbol(assignmentStatement),
      name: 'a',
      value: [Object],
      declarationType: 'var'
    }
  }
]
TOP: 3 {
  state: Symbol(block),
  node: {
    type: Symbol(assignmentStatement),
    name: 'a',
    value: {
      type: Symbol(completeExpression),
      functionName: 'test',
      arguments: [Array]
    },
    declarationType: 'var'
  }
}
[
  {},
  {
    "node": {
      "name": "test",
      "parameters": [
        {
          "value": "a"
        },
        {
          "value": "b"
        }
      ],
      "body": {
        "statements": [
          {}
        ]
      }
    }
  },
  {
    "node": {
      "name": "a",
      "value": {
        "functionName": "test",
        "arguments": [
          {
            "vlaue": "1"
          },
          {
            "vlaue": "2"
          }
        ]
      },
      "declarationType": "var"
    }
  }
]
